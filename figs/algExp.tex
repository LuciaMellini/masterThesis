\begin{algorithm}
\caption{Experiment outline}\label{alg:exp}
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}

\Input{
    Graph $G = (V, E_{\text{train}}, E_{\text{val}}, E_{\text{test}})$ \\
    Hyperparameters
}
\Output{
    Node embeddings $Z$, metrics for each epoch $M$
}

\BlankLine
\SetKwProg{Fn}{Procedure}{}{end}
\Fn{experiment($G$, hyperparameters)}{
    Initialize HGCN model $HGCN(\cdot)$, optimizer, learning rate scheduler\;
    $S \gets$ mini-batch neighbor sampler\;
    $S_{\text{full}} \gets$ full-neighborhood sampler\;

    \ForEach{$\text{epoch}$}{
        \tcp{Training}
        \ForEach{seed-batch $B \subset V$ sampled by $S$}{
            Extract subgraph $G_B$ induced by $B$\;
            $Z_B \gets HGCN(\text{$G_B$})$ \tcp*[r]{Forward pass}
            $E_{\text{train}_{\text{pos}}} \gets$ edges within $G_B$\;
            $E_{\text{train}_{\text{neg}}} \gets$ negative samples\;
            $M \gets M \cup \text{compute\_metrics}(Z_B, E_{\text{train}_{\text{pos}}}, E_{\text{train}_{\text{neg}}})$\;
            Backpropagation on $HGCN(\cdot)$\;
        }
        Learning rate scheduler step\; 
        Log training metrics\;

        \tcp{Periodic inference \& validation}
        \If{$\text{epoch}$ is an evaluation step}{
            Extract subgraph $G_{B_{\text{full}}}$ induced by $B_{\text{full}}$\;
            \ForEach{inference batch $B_{\text{full}}\subset V$ sampled by $S_{\text{full}}$}{
                $Z \gets Z \cup HGCN(B_{\text{full}})$\;
               
            } 
            $E_{\text{val}_{\text{pos}}} \gets$  edges within $G_B$\;
            $E_{\text{val}_{\text{neg}}} \gets$ negative samples\;
            $M \gets M \cup \text{compute\_metrics}(Z, E_{\text{val}_{\text{pos}}}, E_{\text{val}_{\text{neg}}})$\;
        }
    }

    $E_{\text{test}_{\text{pos}}} \gets$ edges within $G_B$\;
    $E_{\text{test}_{\text{neg}}} \gets$ negative samples\;
    $M \gets M \cup \text{compute\_metrics}(Z, E_{\text{test}_{\text{pos}}}, E_{\text{test}_{\text{neg}}})$\;

    \Return{$Z$, $M$}\;
}
\end{algorithm}
